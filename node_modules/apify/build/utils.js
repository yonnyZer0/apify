'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addCharsetToContentType = exports.redactParsedUrl = exports.redactUrl = exports.parseUrl = exports.newClient = exports.nodeifyPromise = exports.newPromise = exports.getPromisePrototype = exports.getPromisesDependency = exports.setPromisesDependency = undefined;

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _contentType = require('content-type');

var _contentType2 = _interopRequireDefault(_contentType);

var _apifyClient = require('apify-client');

var _apifyClient2 = _interopRequireDefault(_apifyClient);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PromisesDependency = typeof Promise === 'function' ? Promise : null;

/* global process */

// TODO: add methods to override console.log() and console.error(), add unit tests for that!

// TODO: use bluebird promise by default instead of native promise, rename newPromise() to newUserPromise(), get rid of nodeifyPromise()

/**
 * @memberof module:Apify
 * @function
 * @description <p>Sets the promise dependency that the package will use wherever promises are returned.
 * Passing `null` will force the SDK to use native Promises if they are available.</p>
 * <p>Example usage</p>
 * <pre><code class="language-javascript">const Promise = require('bluebird');
 * const Apify = require('apify');
 * &nbsp;
 * Apify.setPromisesDependency(Promise);
 * </code></pre>
 * @param [Constructor] dep Reference to a Promise constructor
 */
var setPromisesDependency = exports.setPromisesDependency = function setPromisesDependency(dep) {
    if (dep !== null && typeof dep !== 'function') throw new Error('The "dep" parameter must be a function');
    PromisesDependency = dep;
};

/**
 * @memberof module:Apify
 * @function
 * @description Gets the promise dependency set by <a href="#module-Apify-setPromisesDependency"><code>Apify.setPromisesDependency</code></a>.
 * @returns {Constructor} Reference to a Promise constructor
 */
var getPromisesDependency = exports.getPromisesDependency = function getPromisesDependency() {
    return PromisesDependency;
};

/**
 * Gets a promise dependency set using `setPromisesDependency()`,
 * or returns the native `Promise` function, or throws if no native promises are available.
 * @returns Promise
 * @ignore
 */
var getPromisePrototype = exports.getPromisePrototype = function getPromisePrototype() {
    if (PromisesDependency) {
        if (typeof PromisesDependency.resolve !== 'function') {
            throw new Error('The promise dependency set using Apify.setPromisesDependency() does not define resolve() function.');
        }
        return PromisesDependency;
    }
    if (typeof Promise === 'function') return Promise;
    throw new Error('Native promises are not available, please call Apify.setPromisesDependency() to set a promise library.');
};

/**
 * Returns a result of `Promise.resolve()` using promise library set by `setPromisesDependency()`,
 * or using native promises, or throws if no native promises are available.
 * @returns {*}
 * @ignore
 */
var newPromise = exports.newPromise = function newPromise() {
    return getPromisePrototype().resolve();
};

var nodeifyPromise = exports.nodeifyPromise = function nodeifyPromise(promise, callback) {
    if (!promise) throw new Error('The "promise" parameter must be provided.');

    if (callback) {
        promise.then(function (result) {
            return callback(null, result);
        }, function (err) {
            return callback(err);
        });
    } else {
        return promise;
    }
};

/**
 * Creates an instance of ApifyClient using options as defined in the environment variables.
 * This function is exported in order to enable unit testing.
 * @returns {*}
 * @ignore
 */
var newClient = exports.newClient = function newClient() {
    var opts = {
        userId: process.env[_constants.ENV_VARS.USER_ID] || null,
        token: process.env[_constants.ENV_VARS.TOKEN] || null
    };

    // Only set baseUrl if overridden by env var, so that 'https://api.apify.com' is used by default.
    // This simplifies local development, which should run against production unless user wants otherwise.
    var apiBaseUrl = process.env[_constants.ENV_VARS.API_BASE_URL];
    if (apiBaseUrl) opts.baseUrl = apiBaseUrl;

    return new _apifyClient2.default(opts);
};

/**
 * Sames are Node's url.parse() just adds the 'username', 'password' and 'scheme' fields.
 * @param url
 * @ignore
 */
var parseUrl = exports.parseUrl = function parseUrl(url) {
    var parsed = _url2.default.parse(url);

    parsed.username = null;
    parsed.password = null;
    parsed.scheme = null;

    if (parsed.auth) {
        var matches = /^([^:]+)(:?)(.*)$/.exec(parsed.auth);
        if (matches && matches.length === 4) {
            parsed.username = matches[1];
            if (matches[2] === ':') parsed.password = matches[3];
        }
    }

    if (parsed.protocol) {
        var _matches = /^([a-z0-9]+):$/i.exec(parsed.protocol);
        if (_matches && _matches.length === 2) {
            parsed.scheme = _matches[1];
        }
    }

    return parsed;
};

/**
 * Redacts password from a URL, so that it can be shown in logs, results etc.
 * For example, converts URL such as
 * 'https://username:password@www.example.com/path#hash'
 * to 'https://username:<redacted>@www.example.com/path#hash'
 * @param url URL, it must contain at least protocol and hostname
 * @param passwordReplacement The string that replaces password, by default it is '<redacted>'
 * @returns {string}
 * @ignore
 */
var redactUrl = exports.redactUrl = function redactUrl(url, passwordReplacement) {
    return redactParsedUrl(parseUrl(url), passwordReplacement);
};

var redactParsedUrl = exports.redactParsedUrl = function redactParsedUrl(parsedUrl) {
    var passwordReplacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '<redacted>';

    var p = parsedUrl;
    var auth = null;
    if (p.username) {
        if (p.password) {
            auth = p.username + ':' + passwordReplacement;
        } else {
            auth = '' + p.username;
        }
    }
    return p.protocol + '//' + (auth || '') + (auth ? '@' : '') + p.host + (p.path || '') + (p.hash || '');
};

/**
 * Adds charset=utf-8 to given content type if this parameter is missing.
 *
 * @param contentType
 * @returns {string}
 * @ignore
 */
var addCharsetToContentType = exports.addCharsetToContentType = function addCharsetToContentType(contentType) {
    if (!contentType) return contentType;

    var parsed = _contentType2.default.parse(contentType);

    if (parsed.parameters.charset) return contentType;

    parsed.parameters.charset = 'utf-8';

    return _contentType2.default.format(parsed);
};