'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProxyChain = exports.PROXY_CHAIN = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _tmp = require('tmp');

var _tmp2 = _interopRequireDefault(_tmp);

var _portastic = require('portastic');

var _portastic2 = _interopRequireDefault(_portastic);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _rimraf = require('rimraf');

var _rimraf2 = _interopRequireDefault(_rimraf);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* globals process */

// Constants, exported to simplify unit-testing.
var PROXY_CHAIN = exports.PROXY_CHAIN = {
    PORT_FROM: 55000,
    PORT_TO: 65000,
    HOST: '127.0.0.1',
    PROTOCOL: 'http:',
    SQUID_CMD: 'squid',
    SQUID_CHECK_ARGS: ['-v'],
    SQUID_BATCH_TIMEOUT: 10000,
    TMP_DIR_TEMPLATE: '/tmp/apify-squid-XXXXXX',
    CONF_FILE_NAME: 'squid.conf',
    PID_FILE_NAME: 'squid.pid'
};

var tmpDirPromised = _bluebird2.default.promisify(_tmp2.default.dir);
var fsWriteFilePromised = _bluebird2.default.promisify(_fs2.default.writeFile);
// const execFilePromised = Promise.promisify(childProcess.execFile, { multiArgs: true });

/*
 * Run Squid process to get its version and wait for the finish
 * @returns Promise
 const printSquidVersion = () => {
 // TODO: check that the version is at least 3.3 and throw error otherwise!
 console.log(`${PROXY_CHAIN.LOG_PREFIX}Checking Squid installation with '${PROXY_CHAIN.SQUID_CMD}
 ${PROXY_CHAIN.SQUID_CHECK_ARGS.join(' ')}'`); // eslint-disable-line max-len
 const options = {
 timeout: PROXY_CHAIN.SQUID_BATCH_TIMEOUT,
 };
 return execFilePromised(PROXY_CHAIN.SQUID_CMD, PROXY_CHAIN.SQUID_CHECK_ARGS, options)
 .then((array) => {
 const stdout = array[0];
 console.log(`${PROXY_CHAIN.LOG_PREFIX}${(stdout || '').split('\n')[0]}`);
 this.isInitialized = true;
 })
 .catch((err) => {
 // Give a user-friendly message for this common error
 if (err.code === 'ENOENT') {
 err = new Error(`'${PROXY_CHAIN.SQUID_CMD}' command not found in the PATH`);
 }
 throw err;
 });
 };
*/

/**
 * The class is used to manage a local Squid proxy instance
 * that forwards HTTP requests to a user-provided parent proxy.
 * The point of this is that there's no easy way to programmatically pass proxy
 * authentication credentials to web browsers such as Chrome, so we need to setup
 * a local open proxy that can forward to parent proxy with authentication.
 */

var ProxyChain = exports.ProxyChain = function () {
    /**
     * Creates a new instance of ProxyChain class.
     * @param parsedProxyUrl Proxy URL parsed by calling parseUrl()
     */
    function ProxyChain(parsedProxyUrl) {
        _classCallCheck(this, ProxyChain);

        if (!parsedProxyUrl.hostname || !parsedProxyUrl.port) throw new Error('Proxy URL must contain both hostname and port');
        if (parsedProxyUrl.scheme !== 'http') throw new Error('Only "http" proxy protocol is currently supported');

        this.parsedProxyUrl = parsedProxyUrl;

        // PID of the Squid proxy process
        this.squidPid = null;

        // TCP port where Squid is listening
        this.squidPort = null;

        // Path to temporary directory with config files
        this.tmpDir = null;
    }

    _createClass(ProxyChain, [{
        key: '_getChildProxyUrl',
        value: function _getChildProxyUrl() {
            return PROXY_CHAIN.PROTOCOL + '//' + PROXY_CHAIN.HOST + ':' + this.squidPort;
        }
    }, {
        key: '_getParentProxyUrl',
        value: function _getParentProxyUrl() {
            return (0, _utils.redactParsedUrl)(this.parsedProxyUrl);
        }

        /**
         * Creates the temporary directory, writes a config to it and starts Squid process.
         * @returns Promise
         * @private
         */

    }, {
        key: 'start',
        value: function start() {
            var _this = this;

            // Create temporary directory, if not created yet
            return tmpDirPromised({ template: PROXY_CHAIN.TMP_DIR_TEMPLATE }).then(function (tmpDir) {
                _this.tmpDir = tmpDir;

                return ProxyChain._findFreePort();
            }).then(function (port) {
                _this.squidPort = port;

                // Write config file
                return _this._writeSquidConf();
            }).then(function (squidConfPath) {
                // Start Squid process
                var cmd = PROXY_CHAIN.SQUID_CMD;
                var args = ['-f', squidConfPath, '-N'];
                var options = { cwd: _this.tmpDir };
                console.log('Starting proxy chain: ' + cmd + ' ' + args.join(' '));
                var proc = _child_process2.default.spawn(cmd, args, options);

                _this.squidPid = proc.pid;

                // Wait for Squid process to be running or fail
                return new _bluebird2.default(function (resolve, reject) {
                    var isFinished = false;
                    var intervalId = setInterval(function () {
                        if (_this._isSquidRunning()) {
                            clearInterval(intervalId);
                            isFinished = true;
                            resolve();
                        }
                        // console.log("NOT RUNNING");
                    }, 50);

                    proc.on('exit', function (code, signal) {
                        if (isFinished) {
                            console.log('Squid process ' + _this.squidPid + ' exited (code: ' + code + ', signal: ' + signal + ', temp dir: ' + _this.tmpDir + ')');
                            return;
                        }

                        clearInterval(intervalId);
                        isFinished = true;
                        var msg = 'Squid process ' + _this.squidPid + ' exited unexpectedly (code: ' + code + ', signal: ' + signal + ', temp dir: ' + _this.tmpDir + ')';
                        reject(new Error(msg));
                    });

                    proc.on('error', function (err) {
                        if (isFinished) {
                            console.log('Squid process ' + _this.squidPid + ' failed: ' + err);
                            return;
                        }

                        // Give a user-friendly message for this common error
                        if (err.code === 'ENOENT') {
                            err = new Error('\'' + PROXY_CHAIN.SQUID_CMD + '\' command not found in the PATH');
                        }

                        clearInterval(intervalId);
                        isFinished = true;
                        reject(err);
                    });

                    // Print stdout/stderr to simplify debugging
                    var printLog = function printLog(data) {
                        console.log('Squid process ' + _this.squidPid + ' says: ' + data);
                    };
                    proc.stdout.on('data', printLog);
                    proc.stderr.on('data', printLog);
                });
            }).then(function () {
                var childProxyUrl = _this._getChildProxyUrl();
                console.log('Started proxy chain ' + childProxyUrl + ' => ' + _this._getParentProxyUrl() + ' (Squid pid: ' + _this.squidPid + ', temp dir: ' + _this.tmpDir + ')'); // eslint-disable-line max-len

                return (0, _utils.parseUrl)(childProxyUrl);
            });
        }
    }, {
        key: '_isSquidRunning',


        /**
         * Determines whether the Squid process is still running.
         * @returns Boolean
         * @private
         */
        value: function _isSquidRunning() {
            // Inspired by https://github.com/nisaacson/is-running/blob/master/index.js
            if (!this.squidPid) return false;
            try {
                return !!process.kill(this.squidPid, 0);
            } catch (e) {
                return e.code === 'EPERM';
            }
        }

        /**
         * Generates Squid proxy configuration file and writes it to the temporary directory.
         * @returns Promise Promise resolving to the path to the configuration file.
         * @private
         */

    }, {
        key: '_writeSquidConf',
        value: function _writeSquidConf() {
            if (!this.tmpDir) throw new Error('Temporary directory not created yet');

            var proxy = this.parsedProxyUrl;

            // NOTE: need to set pid_filename to isolate our squid instance from others possibly running in the system
            var conf = '\nvisible_hostname apify-actor\n# debug_options 44,9 28,9\nhttp_access allow all\nnever_direct allow all\n# this probably requires --enable-http-violations compile option\nvia off \nforwarded_for transparent\naccess_log none\n#access_log daemon:' + _path2.default.join(this.tmpDir, 'access.log') + ' squid\n# An attempt to reduce memory consumption (proxy shouldn\'t store anything)\ncache deny all\nmemory_pools off\ncache_mem 16 MB\ncache_store_log none\ncache_log /dev/null\n#cache_log ' + _path2.default.join(this.tmpDir, 'cache.log') + '\nlogfile_rotate 0\npid_filename ' + _path2.default.join(this.tmpDir, PROXY_CHAIN.PID_FILE_NAME) + '\n\nhttp_port ' + this.squidPort + '\ncache_peer ' + proxy.hostname + ' parent ' + proxy.port + ' 0 no-query login=' + proxy.auth + ' connect-fail-limit=99999999 proxy-only name=my_peer\ncache_peer_access my_peer allow all\n';
            var filePath = _path2.default.join(this.tmpDir, PROXY_CHAIN.CONF_FILE_NAME);

            // console.log('CONFIG');
            // console.log(conf);

            return fsWriteFilePromised(filePath, conf).then(function () {
                return filePath;
            });
        }

        /**
         * Removes all proxy chains and terminates the squid process.
         * @returns {*}
         */

    }, {
        key: 'shutdown',
        value: function shutdown() {
            var isRunning = this._isSquidRunning();

            console.log('Shutting down proxy chain ' + this._getChildProxyUrl() + ' => ' + this._getParentProxyUrl() + ' (Squid pid: ' + this.squidPid + ', running: ' + isRunning + ')'); // eslint-disable-line max-len

            if (isRunning) {
                try {
                    process.kill(this.squidPid, 'SIGKILL');
                } catch (err) {
                    console.log('WARNING: Failed to kill Squid process ' + this.squidPid + ': ' + err);
                }
            }

            if (this.tmpDir) {
                var tmpDir = this.tmpDir;
                (0, _rimraf2.default)(tmpDir, { glob: false }, function (err) {
                    if (err) {
                        console.log('WARNING: Failed to delete temporary directory at ' + tmpDir + ': ' + err);
                    }
                });
                this.tmpDir = null;
            }
        }
    }], [{
        key: '_findFreePort',
        value: function _findFreePort() {
            // Let 'min' be a random value in the first half of the PORT_FROM-PORT_TO range,
            // to reduce a chance of collision if other ProxyChain is started at the same time.
            var half = Math.floor((PROXY_CHAIN.PORT_TO - PROXY_CHAIN.PORT_FROM) / 2);

            var opts = {
                min: PROXY_CHAIN.PORT_FROM + Math.floor(Math.random() * half),
                max: PROXY_CHAIN.PORT_TO,
                retrieve: 1
            };

            return _portastic2.default.find(opts).then(function (ports) {
                if (ports.length < 1) throw new Error('There are no more free ports in range from ' + PROXY_CHAIN.PORT_FROM + ' to ' + PROXY_CHAIN.PORT_TO); // eslint-disable-line max-len
                return ports[0];
            });
        }
    }]);

    return ProxyChain;
}();