'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.call = exports.readyFreddy = exports.main = exports.getEnv = exports.setValue = exports.getValue = exports.apifyClient = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _contentType = require('content-type');

var _contentType2 = _interopRequireDefault(_contentType);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _utils = require('apify-client/build/utils');

var _constants = require('./constants');

var _utils2 = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global process, Buffer */

/**
 * @memberof module:Apify
 * @name client
 * @instance
 * @description <p>A default instance of the `ApifyClient` class provided
 * by the {@link https://www.apify.com/docs/sdk/apify-client-js/latest|apify-client} NPM package.
 * The instance is created when the `apify` package is first imported
 * and it is configured using the `APIFY_API_BASE_URL`, `APIFY_USER_ID` and `APIFY_TOKEN`
 * environment variables.
 * After that, the instance is used for all underlying calls to the Apify API
 * in functions such as <a href="#module-Apify-getValue">Apify.getValue()</a>
 * or <a href="#module-Apify-call">Apify.call()</a>.
 * The settings of the client can be globally altered by calling the
 * <a href="https://www.apify.com/docs/js/apify-client-js/latest#ApifyClient-setOptions"><code>Apify.client.setOptions()</code></a> function.
 * Just be careful, it might have undesired effects on other functions provided by this package.
 * </p>
 */
var apifyClient = exports.apifyClient = (0, _utils2.newClient)();

var readFilePromised = _bluebird2.default.promisify(_fs2.default.readFile);
var writeFilePromised = _bluebird2.default.promisify(_fs2.default.writeFile);
var unlinkPromised = _bluebird2.default.promisify(_fs2.default.unlink);
var statPromised = _bluebird2.default.promisify(_fs2.default.stat);

/**
 * Tries to parse a string with date.
 * @param str Date string
 * @returns Returns either a Date object or undefined
 * @ignore
 */
var tryParseDate = function tryParseDate(str) {
    var unix = Date.parse(str);
    return unix > 0 ? new Date(unix) : undefined;
};

var getDefaultStoreIdOrThrow = function getDefaultStoreIdOrThrow() {
    var storeId = process.env[_constants.ENV_VARS.DEFAULT_KEY_VALUE_STORE_ID];
    if (!storeId) throw new Error('The \'' + _constants.ENV_VARS.DEFAULT_KEY_VALUE_STORE_ID + '\' environment variable is not defined.');
    return storeId;
};

/**
 * @memberof module:Apify
 * @function
 * @description <p>Gets a value from the default key-value store for the current act run using the Apify API.
 * The key-value store is created automatically for each act run
 * and its ID is passed by the Actor platform in the `APIFY_DEFAULT_KEY_VALUE_STORE_ID` environment variable.
 * It is used to store input and output of the act under keys named `INPUT` and `OUTPUT`, respectively.
 * However, the store can be used for storage of any other values under arbitrary keys.
 * </p>
 * <p>Example usage</p>
 * <pre><code class="language-javascript">const input = await Apify.getValue('INPUT');
 *
 * console.log('My input:');
 * console.dir(input);
 * </code></pre>
 * <p>
 * The result of the function is the body of the record. Bodies with the `application/json`
 * content type are automatically parsed to an object.
 * Similarly, for `text/plain` content types the body is parsed as `String`.
 * For all other content types, the body is a raw `Buffer`.
 * If the record cannot be found, the result is null.
 * </p>
 * <p>
 * If the `APIFY_DEV_KEY_VALUE_STORE_DIR` environment variable is defined,
 * the value is read from a that directory rather than the key-value store,
 * specifically from a file that has the key as a name.
 * The directory must exist or an error is thrown. If the file does not exists, the returned value is `null`.
 * The file is assumed to have a content type specified in the `APIFY_DEV_KEY_VALUE_STORE_CONTENT_TYPE`
 * environment variable, or `application/json` if not set.
 * This feature is useful for local development and debugging of your acts.
 * </p>
 * @param {Function} callback Optional callback.
 * @returns {Promise} Returns a promise if no callback was provided.
 */
var getValue = exports.getValue = function getValue(key) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (!key || !_underscore2.default.isString(key)) throw new Error('The "key" parameter must be a non-empty string');

    var devDir = process.env[_constants.ENV_VARS.DEV_KEY_VALUE_STORE_DIR];
    var promise = void 0;

    if (devDir) {
        // We're emulating KV store locally in a directory to simplify development
        var devContentType = process.env[_constants.ENV_VARS.DEV_KEY_VALUE_STORE_CONTENT_TYPE] || 'application/json; charset=utf-8';
        var contentType = _contentType2.default.parse(devContentType).type;
        var dirPath = _path2.default.resolve(devDir);
        var filePath = void 0;

        promise = (0, _utils2.newPromise)().then(function () {
            // Check that the directory is really a directory
            return statPromised(dirPath).then(function (stats) {
                if (!stats.isDirectory()) throw new Error('The directory is not a directory');
            }).catch(function (err) {
                if (err.code === 'ENOENT') throw new Error('The directory does not exist');
                throw err;
            });
        }).then(function () {
            // Read file
            filePath = _path2.default.resolve(dirPath, key);
            return readFilePromised(filePath).catch(function (err) {
                if (err.code === 'ENOENT') return null;
                throw err;
            });
        }).then(function (data) {
            // Parse file according to the content type
            if (data !== null) {
                if (contentType === 'application/json') {
                    try {
                        data = JSON.parse(data.toString('utf8'));
                    } catch (e) {
                        throw new Error('File cannot be parsed as JSON: ' + e.message);
                    }
                } else if (contentType === 'text/plain') {
                    data = data.toString();
                }
            }
            return data;
        }).catch(function (err) {
            throw new Error('Error reading file \'' + key + '\' in directory \'' + dirPath + '\' referred by ' + _constants.ENV_VARS.DEV_KEY_VALUE_STORE_DIR + ' environment variable: ' + err.message); // eslint-disable-line max-len
        });
    } else {
        var storeId = getDefaultStoreIdOrThrow();
        var promisePrototype = (0, _utils2.getPromisePrototype)();

        promise = (0, _utils2.newPromise)().then(function () {
            return apifyClient.keyValueStores.getRecord({
                storeId: storeId,
                promise: promisePrototype,
                key: key
            }).then(function (output) {
                return output ? output.body : null;
            });
        });
    }

    return (0, _utils2.nodeifyPromise)(promise, callback);
};

/**
 * @memberof module:Apify
 * @function
 * @description <p>Stores a value in the default key-value store for the current act run using the Apify API.
 * The data is stored in the key-value store created specifically for the act run,
 * whose ID is defined in the `APIFY_DEFAULT_KEY_VALUE_STORE_ID` environment variable.
 * The function has no result, but throws on invalid args or other errors.</p>
 * <pre><code class="language-javascript">await Apify.setValue('OUTPUT', { someValue: 123 });</code></pre>
 * <p>
 * By default, `value` is converted to JSON and stored with the `application/json; charset=utf-8` content type.
 * To store a value with another content type, pass it in the options as follows:
 * </p>
 * <pre><code class="language-javascript">await Apify.setValue('OUTPUT', 'my text data', { contentType: 'text/plain' });</code></pre>
 * <p>
 * In this case, the value must be a string or Buffer.
 * </p>
 * <p>
 * If the `APIFY_DEV_KEY_VALUE_STORE_DIR` environment variable is defined,
 * the value is written to that local directory rather than the key-value store on Apify cloud,
 * to a file named as the key. This is useful for local development and debugging of your acts.
 * </p>
 * <p>
 * **IMPORTANT: Do not forget to use the `await` keyword when calling `Apify.setValue()`,
 * otherwise the act process might finish before the value is stored!**
 * </p>
 * @param key Key of the record
 * @param value Value of the record:
 * <ul>
 *  <li>If `null`, the record in the key-value store is deleted.</li>
 *  <li>If no `options.contentType` is specified, `value` can be any object and it will be stringified to JSON.</li>
 *  <li>If `options.contentType` is specified, `value` is considered raw data and it must be a String or Buffer.</li>
 * </ul>
 * For any other value an error will be thrown.
 * @param {Object} [options]
 * @param {String} [options.contentType] - Sets the MIME content type of the value.
 * @param {Function} [callback] Optional callback. Function returns a promise if not provided.
 * @returns {Promise} Returns a promise if `callback` was not provided.
 */
var setValue = exports.setValue = function setValue(key, value, options) {
    var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    if (!key || !_underscore2.default.isString(key)) throw new Error('The "key" parameter must be a non-empty string');

    // contentType is optional
    if (_underscore2.default.isFunction(options)) {
        callback = options;
        options = null;
    }

    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' && options !== undefined) throw new Error('The "options" parameter must be an object, null or undefined.');
    // Make copy of options, don't update what user passed
    options = Object.assign({}, options);

    var promisePrototype = (0, _utils2.getPromisePrototype)();

    var storeId = null;

    // Handle emulation of KV store locally in a directory to simplify development
    var devDir = process.env[_constants.ENV_VARS.DEV_KEY_VALUE_STORE_DIR];
    var devDirPath = void 0;
    var devFilePath = void 0;
    if (devDir) {
        // Get absolute paths
        devDirPath = _path2.default.resolve(devDir);
        devFilePath = _path2.default.resolve(devDirPath, key);
    } else {
        // This would throw if APIFY_DEFAULT_KEY_VALUE_STORE_ID env var was not set
        storeId = getDefaultStoreIdOrThrow();
    }
    var devErrorHandler = function devErrorHandler(err) {
        throw new Error('Error writing file \'' + key + '\' in directory \'' + devDirPath + '\' referred by ' + _constants.ENV_VARS.DEV_KEY_VALUE_STORE_DIR + ' environment variable: ' + err.message); // eslint-disable-line max-len
    };

    var innerPromise = void 0;

    if (value !== null) {
        // Normal case: put record to store
        // If contentType is missing, value will be stringified to JSON
        if (options.contentType === null || options.contentType === undefined) {
            options.contentType = 'application/json';
            try {
                // Format JSON to simplify debugging, the overheads with compression is negligible
                value = JSON.stringify(value, null, 2);
            } catch (e) {
                throw new Error('The "value" parameter cannot be stringified to JSON: ' + e.message);
            }
            if (value === undefined) {
                throw new Error('The "value" parameter cannot be stringified to JSON.');
            }
        }

        if (!options.contentType || !_underscore2.default.isString(options.contentType)) {
            throw new Error('The "options.contentType" parameter must be a non-empty string, null or undefined.');
        }
        if (!_underscore2.default.isString(value) && !Buffer.isBuffer(value)) {
            throw new Error('The "value" parameter must be a String or Buffer when "contentType" is specified.');
        }

        if (devFilePath) {
            innerPromise = writeFilePromised(devFilePath, value).catch(devErrorHandler);
        } else {
            // Keep this code in main scope so that simple errors are thrown rather than rejected promise.
            innerPromise = apifyClient.keyValueStores.putRecord({
                storeId: storeId,
                promise: promisePrototype,
                key: key,
                body: value,
                contentType: (0, _utils2.addCharsetToContentType)(options.contentType)
            });
        }
    } else {
        // Special case: remove the record from the store
        if (options.contentType !== null && options.contentType !== undefined) {
            throw new Error('The "options.contentType" parameter must not be used when removing the record.');
        }
        if (devFilePath) {
            innerPromise = unlinkPromised(devFilePath).catch(devErrorHandler);
        } else {
            innerPromise = apifyClient.keyValueStores.deleteRecord({
                storeId: storeId,
                promise: promisePrototype,
                key: key
            });
        }
    }

    var promise = (0, _utils2.newPromise)().then(function () {
        return innerPromise;
    });
    return (0, _utils2.nodeifyPromise)(promise, callback);
};

/**
 * @memberof module:Apify
 * @function
 * @description <p>Returns a new object which contains information parsed from the `APIFY_XXX` environment variables.
 * It has the following properties:</p>
 * <pre><code class="language-javascript">{
 *     // ID of the act (APIFY_ACT_ID)
 *     actId: String,
 * &nbsp;
 *     // ID of the act run (APIFY_ACT_RUN_ID)
 *     actRunId: String,
 * &nbsp;
 *     // ID of the user who started the act - note that it might be
 *     // different than the owner of the act (APIFY_USER_ID)
 *     userId: String,
 * &nbsp;
 *     // Authentication token representing privileges given to the act run,
 *     // it can be passed to various Apify APIs (APIFY_TOKEN).
 *     token: String,
 * &nbsp;
 *     // Date when the act was started (APIFY_STARTED_AT)
 *     startedAt: Date,
 * &nbsp;
 *     // Date when the act will time out (APIFY_TIMEOUT_AT)
 *     timeoutAt: Date,
 * &nbsp;
 *     // ID of the key-value store where input and output data of this
 *     // act is stored (APIFY_DEFAULT_KEY_VALUE_STORE_ID)
 *     defaultKeyValueStoreId: String,
 * &nbsp;
 *     // Amount of memory allocated for the act run,
 *     // in megabytes (APIFY_MEMORY_MBYTES)
 *     memoryMbytes: Number,
 * }
 * </code></pre>
 * For the list of the `APIFY_XXX` environment variables, see
 * {@link http://localhost/docs/actor.php#run-env-vars|Actor documentation}.
 * If some of the variables is not defined or is invalid, the corresponding value in the resulting object will be null.
 * @returns {Object}
 */
var getEnv = exports.getEnv = function getEnv() {
    // NOTE: Don't throw if env vars are invalid to simplify local development and debugging of acts
    var env = process.env || {};
    return {
        actId: env[_constants.ENV_VARS.ACT_ID] || null,
        actRunId: env[_constants.ENV_VARS.ACT_RUN_ID] || null,
        userId: env[_constants.ENV_VARS.USER_ID] || null,
        token: env[_constants.ENV_VARS.TOKEN] || null,
        startedAt: tryParseDate(env[_constants.ENV_VARS.STARTED_AT]) || null,
        timeoutAt: tryParseDate(env[_constants.ENV_VARS.TIMEOUT_AT]) || null,
        defaultKeyValueStoreId: env[_constants.ENV_VARS.DEFAULT_KEY_VALUE_STORE_ID] || null,
        // internalPort: parseInt(env[ENV_VARS.INTERNAL_PORT], 10) || null,
        memoryMbytes: parseInt(env[_constants.ENV_VARS.MEMORY_MBYTES], 10) || null
    };
};

/**
 * @memberof module:Apify
 * @function
 * @description <p>Runs a user function that performs the logic of the act.
 * The `Apify.main(userFunct)` function does the following actions:</p>
 * <ol>
 *   <li>Invokes the user function passed as the `userFunc` parameter</li>
 *   <li>If the user function returned a promise, waits for it to resolve</li>
 *   <li>If the user function throws an exception or some other error is encountered,
 *       prints error details to console so that they are stored to the log file</li>
 *   <li>Exits the process</li>
 * </ol>
 * <p>
 * In the simplest case, the user function is synchronous:
 * </p>
 * ```javascript
 * Apify.main(() => {
 *     // My synchronous function that returns immediately
 * });
 * ```
 * <p>If the user function returns a promise, it is considered as asynchronous:</p>
 * ```javascript
 * const request = require('request-promise');
 * Apify.main(() => {
 *     // My asynchronous function that returns a promise
 *     return Promise.resolve()
 *     .then(() => {
 *         return request('http://www.example.com');
 *     })
 *     .then((html) => {
 *         console.log(html);
 *     });
 * });
 * ```
 * <p>To simplify your code, you can take advantage of the `async`/`await` keywords:</p>
 * ```javascript
 * const request = require('request-promise');
 * Apify.main(async () => {
 *      const html = await request('http://www.example.com');
 *      console.log(html);
 * });
 * ```
 * Note that the use of `Apify.main()` in acts is optional;
 * the function is provided merely for user convenience and acts don't need to use it.
 * @param userFunc {Function} User function to be executed
 */
var main = exports.main = function main(userFunc) {
    if (!userFunc || typeof userFunc !== 'function') {
        throw new Error('Handler function must be provided as a parameter');
    }

    // This is to enable unit tests where process.exit() is mocked and doesn't really exit the process
    // Note that mocked process.exit() might throw, so set exited flag before calling it to avoid confusion.
    var exited = false;
    var exitWithError = function exitWithError(err, exitCode, message) {
        console.error(message);
        console.error(err.stack || err);
        exited = true;
        // console.log(`Exiting with code: ${exitCode}`);
        process.exit(exitCode);
    };

    // Set dummy interval to ensure the process will not be killed while awaiting empty promise:
    // await new Promise(() => {})
    // Such a construct is used to for testing of act timeouts and aborts.
    var intervalId = setInterval(_underscore2.default.noop, 9999999);

    try {
        (0, _utils2.newPromise)().then(function () {
            return userFunc();
        }).catch(function (err) {
            clearInterval(intervalId);
            if (!exited) {
                exitWithError(err, _constants.EXIT_CODES.ERROR_USER_FUNCTION_THREW, 'User function threw an exception:');
            }
        }).then(function () {
            clearInterval(intervalId);
            if (!exited) {
                process.exit(_constants.EXIT_CODES.SUCCESS);
            }
        });
    } catch (err) {
        // This can happen e.g. if there's no Promise dependency
        exitWithError(err, _constants.EXIT_CODES.ERROR_UNKNOWN, 'Unknown error occurred');
    }
};

// TODO: this should rather be called Apify.listeningOnPort() or something like that

/**
 * @ignore
 * @memberof module:Apify
 * @function
 * @description Notifies Apify runtime that act is listening on port specified by the APIFY_INTERNAL_PORT environment
 * variable and is ready to receive a HTTP request with act input.
 */
var readyFreddy = exports.readyFreddy = function readyFreddy() {
    var watchFileName = process.env[_constants.ENV_VARS.WATCH_FILE];
    if (watchFileName) {
        _fs2.default.writeFile(watchFileName, '', function (err) {
            if (err) console.log('WARNING: Cannot write to watch file ' + watchFileName + ': ' + err);
        });
    } else {
        console.log('WARNING: ' + _constants.ENV_VARS.WATCH_FILE + ' environment variable not specified, readyFreddy() has no effect.');
    }
};

/**
 * @memberof module:Apify
 * @function
 * @description <p>Executes another act under the current user account, waits for the act finish and fetches its output.</p>
 * <p>The result of the function is an object describing the act run, which looks something like this:</p>
 * ```json
 * {
 *   "id": "ErYkuTTsmKiXccNGT",
 *   "actId": "E2jjCZBezvAZnX8Rb",
 *   "userId": "mb7q2dycFBHDhae6A",
 *   "startedAt": "2017-10-25T14:23:44.376Z",
 *   "finishedAt": "2017-10-25T14:23:46.723Z",
 *   "status": "SUCCEEDED",
 *   "meta": { "origin": "API", "clientIp": "1.2.3.4", "userAgent": null },
 *   "stats": {
 *       "netRxBytes": 180,
 *       "netTxBytes": 0,
 *       ...
 *   },
 *   "options": {
 *      "build": "latest",
 *      "timeoutSecs": 0,
 *      "memoryMbytes": 512,
 *      "diskMbytes": 1024
 *   },
 *   "buildId": "Bwkqk59MCkdexDP34",
 *   "exitCode": 0,
 *   "defaultKeyValueStoreId": "ccFfRptZru2uqdQHP",
 *   "buildNumber": "0.1.2",
 *   "output": {
 *       "contentType": "application/json; charset=utf-8",
 *       "body": { "message": "Hello world!" }
 *   }
 * }
 * ```
 * <p>Internally, the function calls the {@link https://www.apify.com/docs/api/v2#/reference/acts/runs-collection/run-act|Run act} API endpoint
 * and few others.</p>
 * <p>Example usage:</p>
 * ```javascript
 * const run = await Apify.call('apify/hello-world', { myInput: 123 });
 * console.log(`Received message: ${run.output.body.message}`);
 * ```
 *
 * @param {String} actId - Either `username/act-name` or act ID.
 * @param {Object|String|Buffer} [input] - Act input body. If it is an object, it is stringified to
 * JSON and the content type set to `application/json; charset=utf-8`.
 * @param {Object} [opts]
 * @param {String} [opts.token] - User API token. By default, it is taken from the `APIFY_TOKEN` environment variable.
 * @param {String} [opts.build] - Tag or number of act build to be run (e.g. `beta` or `1.2.345`).
 * If not provided, the default build tag or number from act configuration is used (typically `latest`).
 * @param {String} [opts.contentType] - Content type for the `input`. If not specified,
 * `input` is expected to be an object that will be stringified to JSON and content type set to
 * `application/json; charset=utf-8`. If `opts.contentType` is specified, then `input` must be a `String` or `Buffer`.
 * @param {String} [opts.timeoutSecs] - Time limit for act to finish, in seconds.
 * If the limit is reached the resulting run will have the `RUNNING` status.
 * By default, there is no timeout.
 * @param {String} [opts.fetchOutput] - If `false` then the function does not fetch output of the act. Default is `true`.
 * @param {String} [opts.disableBodyParser] - If `true` then the function will not attempt to parse the
 * act's output and will return it in a raw `Buffer`. Default is `false`.
 * @param {Function} [callback] - Optional callback. Function returns a promise if not provided.
 * @returns {Promise} Returns a promise unless `callback` was supplied.
 */
var call = exports.call = function call(actId, input) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = arguments[3];
    var acts = apifyClient.acts,
        keyValueStores = apifyClient.keyValueStores;


    (0, _utils.checkParamOrThrow)(actId, 'actId', 'String');
    (0, _utils.checkParamOrThrow)(opts, 'opts', 'Object');

    // Common options.
    var token = opts.token;

    (0, _utils.checkParamOrThrow)(token, 'token', 'Maybe String');
    var defaultOpts = { actId: actId };
    if (token) defaultOpts.token = token;

    // RunAct() options.
    var build = opts.build;

    var runActOpts = {};
    (0, _utils.checkParamOrThrow)(build, 'build', 'Maybe String');
    if (build) runActOpts.build = build;

    var contentType = opts.contentType;

    if (input) {
        // TODO: this is duplicate with setValue()'s code
        if (contentType === null || contentType === undefined) {
            contentType = 'application/json';
            try {
                // Format JSON to simplify debugging, the overheads with compression is negligible
                input = JSON.stringify(input, null, 2);
            } catch (err) {
                throw new Error('The "input" parameter cannot be stringified to JSON: ' + err.message);
            }
            if (input === undefined) {
                throw new Error('The "input" parameter cannot be stringified to JSON.');
            }
        }

        (0, _utils.checkParamOrThrow)(input, 'input', 'Buffer|String');
        (0, _utils.checkParamOrThrow)(contentType, 'contentType', 'String');

        if (contentType) runActOpts.contentType = (0, _utils2.addCharsetToContentType)(contentType);
        runActOpts.body = input;
    }

    // GetAct() options.
    var timeoutSecs = opts.timeoutSecs,
        _opts$fetchOutput = opts.fetchOutput,
        fetchOutput = _opts$fetchOutput === undefined ? true : _opts$fetchOutput;

    (0, _utils.checkParamOrThrow)(timeoutSecs, 'timeoutSecs', 'Maybe Number');
    (0, _utils.checkParamOrThrow)(fetchOutput, 'fetchOutput', 'Boolean');
    var timeoutAt = timeoutSecs ? Date.now() + timeoutSecs * 1000 : null;

    // GetRecord() options.
    var disableBodyParser = opts.disableBodyParser;

    (0, _utils.checkParamOrThrow)(disableBodyParser, 'disableBodyParser', 'Maybe Boolean');

    // Adds run.output field to given run and returns it.
    var addOutputToRun = function addOutputToRun(run) {
        var getRecordOpts = { key: 'OUTPUT', storeId: run.defaultKeyValueStoreId };
        if (disableBodyParser) getRecordOpts.disableBodyParser = disableBodyParser;

        return keyValueStores.getRecord(getRecordOpts).then(function (output) {
            return Object.assign({}, run, { output: output });
        });
    };

    // Keeps requesting given run until it gets finished or timeout is reached.
    var waitForRunToFinish = function waitForRunToFinish(run) {
        var waitForFinish = timeoutAt !== null ? Math.round((timeoutAt - Date.now()) / 1000) : 999999;

        // We are timing out ...
        if (waitForFinish <= 0) return _bluebird2.default.resolve(run);

        return acts.getRun(Object.assign({}, defaultOpts, { waitForFinish: waitForFinish, runId: run.id })).then(function (updatedRun) {
            if (!_underscore2.default.contains(_constants.ACT_TASK_TERMINAL_STATUSES, updatedRun.status)) return waitForRunToFinish(updatedRun);
            if (!fetchOutput) return updatedRun;

            return addOutputToRun(updatedRun);
        });
    };

    var promise = acts.runAct(Object.assign({}, defaultOpts, runActOpts)).then(function (run) {
        return waitForRunToFinish(run);
    });

    return (0, _utils2.nodeifyPromise)(promise, callback);
};